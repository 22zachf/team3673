/*
 * Changes from V2.1:
 * 
 * -Added second double solenoid for pneumatic tote grabber
 * -Added "manual" piston control (using the POV instead of buttons)
 * -Added reverse mode for "auto" pulley control
 * -Removed testing console messages
 * -Moved drive train switching to button 11 on left stick
 * -Moved panic button to button 7 on left stick
 * -Moved "auto" Pulleys to buttons 3 and 4
 */
package org.usfirst.frc.team3673.robot;

import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Gyro;
import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.buttons.JoystickButton;

/*
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
public class Robot extends IterativeRobot 
{
    Talon motorPulley = new Talon(3); //(PWM port)
    Talon motorFLeft = new Talon(2);
    Talon motorRLeft = new Talon(1);
    Talon motorFRight = new Talon(5);
    Talon motorRRight = new Talon(4);
    RobotDrive chassis = new RobotDrive(motorFLeft, motorRLeft, motorFRight, motorRRight); //declares the motors used for the DriveTrain
    Joystick stickLeft = new Joystick(1); //declares the joystick and its port
        JoystickButton buttonPanic = new JoystickButton(stickLeft, 7), //(stick, button)
                       buttonDriveMode = new JoystickButton(stickLeft, 11);
    Joystick stickRight = new Joystick(0);
        JoystickButton buttonPiston = new JoystickButton(stickRight, 1), //button one is the trigger
                       buttonPulleyForward = new JoystickButton(stickRight, 3),
                       buttonPulleyReverse = new JoystickButton(stickRight, 4);
    DigitalInput limitPulleyBot = new DigitalInput(9), //(DIO port)
                 limitPulleyTop = new DigitalInput(8);
    Gyro gyro = new Gyro(1); //(Analog port)
    DoubleSolenoid dsolPiston1 = new DoubleSolenoid(0, 1);//(Forward channel on PCM, reverse channel on PCM)
    DoubleSolenoid dsolPiston2 = new DoubleSolenoid(2, 3);
    Encoder enc = new Encoder(0, 1, false, Encoder.EncodingType.k4X); //(DIOa, DIOb, Direction, Encoding Type)
    private int count; //see encoder
    private boolean isRobotDead = false; //kill switch
    private boolean statePulleyDown; //When true: pulley is at the bottom ogf the track
    private boolean statePulleyUp; //When true: pulley is at the top of track
    private boolean statePulleyRequestForward; //See teleop
    private boolean statePulleyRequestReverse; // ^
    private boolean statePulleyManualUp; //See TeleOp
    private boolean statePulleyManualDown;
    private boolean statePistonRequest;// ^
    private boolean stopped; //See encoder
    private boolean direction; // ^
    private boolean driveTrainMode = false; //When true: in Cartessian. When false: in polar
    private boolean statePistonExtended = false; //When true: piston is extended
    private boolean stateLastPressed; //Saves when the piston button has been pressed
	private double distance; //See encoder
	double rate; //See encoder
    
	/**
	 *  Initializes motors.
	 */
	private void initMotor()
	{
		//Both right motors will recieve only flipped values from the code (I.E. + to - and - to +)
		chassis.setInvertedMotor(RobotDrive.MotorType.kFrontRight, true);
    	chassis.setInvertedMotor(RobotDrive.MotorType.kRearRight, true);
	}
	
	/**
	 * Initializes the parameters for the encoder.
	 */
    private void initEnc()
    {
        enc.setMinRate(10); //sets minimum rate before the device is considered not moving.
        enc.setDistancePerPulse(5); //sets scale factor between distance and pulses
        enc.setReverseDirection(true); //Sets direction in which the encoder counts.
        enc.setSamplesToAverage(7); //sets how many samples are taken and averaged when called. (must be between 1 and 127)
    }
    
    /**
     * Initializes the gyro
     */
    private void initGyro()
    {
    	gyro.reset(); //Resets the gyro to zero.
    	gyro.startLiveWindowMode(); //This SHOULD give live feed to the DS
    }
    
    /**
     * Initilizes solenoids
     */
    private void initSol()
    {
    	//Pistons set to neutral
    	dsolPiston1.set(DoubleSolenoid.Value.kOff);
    	dsolPiston2.set(DoubleSolenoid.Value.kOff);
    }
    
    /**
     *  Returns the values of certain parameters of the encoder to the RioLog
     */
    private void encoderRead()
    {
    	count = enc.get(); //Gets current count
    	distance = enc.getDistance(); //Gets raw count and translates into distance
    	rate = enc.getRate(); //The rate of the counter (units/sec)
    	direction = enc.getDirection(); //Returns a boolean value based on the direction the motor is going
    	stopped = enc.getStopped(); //returns whether the motor is moving or not
    	
    	System.out.println(count + "\t" + distance + "\t" + rate + "\t" + direction + "\t" + stopped);
    }
    
    /**
     * Returns the rough approximation of the gyro angle to the console.
     */
    private void gyroRead()
    {
    	System.out.println(3.6 * gyro.getAngle());
    	gyro.updateTable();
    }

    /**
     * This function is called when the robot is first started up.
     */
    public void robotInit() 
    {
    	initMotor();
    	initEnc();
    	initGyro();
    	initSol();
    }

    /**
     * This function looped during Autonomous
     */
    public void autonomousPeriodic() 
    {
    	encoderRead();
    	gyroRead();
    }        

    /**
     * This function is looped during operator control
     */
    public void teleopPeriodic() 
    {
    	chassis.setLeftRightMotorOutputs(0,0);
        chassis.setSafetyEnabled(true);
        
        /*
         * These are states and motors that need to be reset every iteration of this loop.
         */
        statePulleyRequestForward = false;
        statePulleyRequestReverse = false;
        statePulleyManualUp = false;
        statePulleyManualDown = false;
        motorPulley.set(0.0);
        System.out.println(stickRight.getPOV());

        /*
         * The following if statements take snapshot of the Joysticks immeadiatly after the loop starts.
         * Theoretically, this make the code run faster and prevents a certain level of "double pressing"
         * and skipping. 
         */
        if(buttonPanic.get())
        {
            isRobotDead =! isRobotDead;//Flips value of "isRobotDead"
        }
        
        if(buttonDriveMode.get())
        {
        	driveTrainMode =! driveTrainMode; //Flips value of "driveTrainMode"
        	gyro.reset(); //Resets gyro to the zero position, regardless of the previous angle.
        }
            
        if(buttonPulleyForward.get())
        {
            statePulleyRequestForward = true;
        }
        else if(buttonPulleyReverse.get())
        {
        	statePulleyRequestReverse = true;
        }
        else
        {
        	statePulleyRequestForward = false;
        	statePulleyRequestReverse = false;
        }
          
        //If POV 0 is at Forward (0), Left Forward (315), or right forward (45) position
        if(stickRight.getPOV(0) == 0 || stickRight.getPOV(0) == 315 || stickRight.getPOV(0) == 45)
        {
            statePulleyRequestForward = false; //Set conflicting values to false
            statePulleyRequestReverse = false;
            statePulleyDown = false;
            statePulleyManualDown = false;
            statePulleyManualUp = true; //set agreeing values to true
            statePulleyUp = true;
        }
        //If POV 0 is at Back (180), Left Back (225), or Right Back (135) position
        else if(stickRight.getPOV(0) == 180 || stickRight.getPOV(0) == 135 || stickRight.getPOV(0) == 225)
        {
            statePulleyRequestForward = false; //Set conflicting values to false
            statePulleyRequestReverse = false;
            statePulleyUp = false;
            statePulleyManualUp = false;
            statePulleyManualDown = true; //set agreeing values to true
            statePulleyDown = true;
        }
        
        if(limitPulleyTop.get()) //Checks to see if the limit switch is active
        {
            statePulleyDown = true; //Allows pulley to move down, and prevents it from moving up.
            statePulleyUp = false;
        }
        else if(limitPulleyBot.get()) //Checks to see if the limit switch is active
        {
            statePulleyDown = false; //vice versa
            statePulleyUp = true;
        }
            
        /*
         * Ok, the piston was a bastard to program. This will require a very long comment chain.
         * Prepare yourself.
         */
        if(buttonPiston.get())//Right, this returns whether the button was pressed.
        {
        	/*
        	 * Note: statePistonRequest is a boolean that holds whether or not the driver asked to 
        	 * fire the piston. If it's false when it gets here, it is set to true to tell the code
        	 * that the driver would like to fire the piston
        	 */
            if(statePistonRequest == false)
            {
            	statePistonRequest = true;
            	stateLastPressed = true;
            	/*
            	 * Note: stateLastPressed is boolean that checks to see if the button was pressed previously. It is 
            	 * ONLY set to true if this part of the code is reached. While the button remains pressed, this prevents
            	 * the code from extending/retracting the piston over and over. It must be released for AT LEAST one full
            	 * loop before the piston can be changed from a state.
            	 */
            }
        }
        else //If the button IS NOT BEING PRESSED
        {
        	/*
        	 * Note: If statePistonRequest is true when it gets here, it is set to false to tell the code
        	 * that the driver would not like to fire the piston
        	 */
            if(statePistonRequest == true)
            {
            	statePistonRequest = false;
            	stateLastPressed = false;
            }
        }
            
        /*
         * After this point, all code is internal (except for temporary controls that will be moved later)
         * This allows the roboRIO to quickly apply all changes desired or required and take another snapshot of
         * the controls.
         */
        if(isRobotDead == false) //If "panic mode" is not enabled
        {	 	
            if(driveTrainMode == false) //Checks to se if the driver wanted to change drive modes
            {
            	chassis.mecanumDrive_Polar(stickRight.getMagnitude(), stickRight.getDirectionDegrees(), stickLeft.getTwist());	
            }
            else
            {
            	chassis.mecanumDrive_Cartesian(stickRight.getX(), stickRight.getY(), stickLeft.getTwist(), 3.6 * gyro.getAngle());
            	gyroRead();
            }
            	
            if(statePulleyRequestForward == true) //Checks to see if the driver wanted to move the pulley foward
            {
                if(statePulleyDown == true) //Checks to see if the pulley is required to move down due to limit switch
                {
                	motorPulley.set(-1.0);
                	encoderRead();
                }
                else // If not, move it up.
                {
                	motorPulley.set(1.0);
                	encoderRead();
                }
            }
            else if(statePulleyRequestReverse == true)
            {
            	if(statePulleyUp == true) //Checks to see if the pulley is required to move up due to limit switch
                {
                	motorPulley.set(1.0);
                	encoderRead();
                }
                else // If not, move it down.
                {
                	motorPulley.set(-1.0);
                	encoderRead();
                }
            }
                
            if(statePulleyManualUp == true) //Checks to se if the driver wanted to manually move the pulleys up
            {
                if(statePulleyDown == true) //Checks to see if the pulley is required to move down
                {
                	motorPulley.set(1.0);
                	encoderRead();
                }
                else //If not, move it up.
                {
                	motorPulley.set(-1.0);
                	encoderRead();
                }
            }
            else if(statePulleyManualDown == true)//Checks to see if the driver wanted to move the pulleys down
            {
            	if(statePulleyUp == true)//Checks to see of the pulleys are required to move up due to a limit switch
            	{
            		motorPulley.set(-1.0);
            		encoderRead();
            	}
            	else //If not, move them down.
            	{
            		motorPulley.set(1.0);
            		encoderRead();
            	}
            }
            
            if(stateLastPressed == true) //if stateLastPressed is true
            {
            	if(statePistonRequest == true)//AND the piston was asked to move
            	{
            		statePistonExtended =! statePistonExtended; //Flip value of "sPE"
            	}
            }
                
            if(statePistonExtended == true) //If "sPE" was flipped to true
            {
            	dsolPiston1.set(DoubleSolenoid.Value.kForward); //Extend pistons
            	dsolPiston2.set(DoubleSolenoid.Value.kForward);
            	stateLastPressed = false; //Set stateLastPressed to false
            	/*
            	 * Note: technically, the code extends the piston everytime it doesn't retract it. But since it cannot
            	 * pump more air into the piston, nothing happens on the robot.
            	 */
            }
            else //If it is false
            {
            	dsolPiston1.set(DoubleSolenoid.Value.kReverse); //retract pistons
            	dsolPiston2.set(DoubleSolenoid.Value.kReverse);
            	stateLastPressed = false; //set "sLP"
            	/*
            	 * Note: technically, the code retracts the piston everytime it doesn't extend it. But due to the fact
            	 * it cannot dump air out of it, nothing happens on the robot.
            	 */
            }
        }
        else //If "isRobotDead" is true
        {
        	//Set all hardware to default, and motors to 0 speed
            motorFLeft.set(0.0);
            motorRLeft.set(0.0);
            motorFRight.set(0.0);
            motorRRight.set(0.0);
            motorPulley.set(0.0);
            gyro.reset();
            dsolPiston1.set(DoubleSolenoid.Value.kOff);
            dsolPiston2.set(DoubleSolenoid.Value.kOff);
            //Return all states (apart from panic mode) to default value
            statePulleyRequestForward = false;
            statePulleyManualUp = false;
            statePulleyManualDown = false;
            statePistonRequest = false;
            stateLastPressed  = false;
            stopped = false;
            driveTrainMode = false;
        }
    }
    
    /**
     * This function is called periodically during test mode
     */
    public void testPeriodic() 
    {
    
    }
}
